{"version":3,"file":"util.js","sourceRoot":"","sources":["../src/util.ts"],"names":[],"mappings":";;AAKA,SAAgB,WAAW,CAA4C,MAAS,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,QAAW;IAC/G,KAAI,MAAM,GAAG,IAAI,QAAQ,EAAE;QACvB,KAAI,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YACrC,IAAG,GAAG,CAAC,CAAC,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,SAAS,EAAE;gBACxC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;aACd;SACJ;KACJ;IACD,OAAO,GAAG,CAAC;AACf,CAAC;AATD,kCASC;AAED,SAAgB,aAAa,CAAC,GAAQ;IAClC,OAAO,QAAQ,CAAC,GAAG,CAAC,IAAI,CACpB,GAAG,CAAC,WAAW,KAAK,MAAM;WACvB,GAAG,CAAC,WAAW,KAAK,SAAS,CACnC,CAAC;AACN,CAAC;AALD,sCAKC;AAED,SAAgB,QAAQ,CAAC,GAAQ;IAC7B,OAAO,GAAG,KAAK,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC;AACnD,CAAC;AAFD,4BAEC","sourcesContent":["import {AnyObject, StringMap, TupleTypes, UnionToIntersection} from './types';\n\n// https://stackoverflow.com/q/51603250/65387\n// https://github.com/Microsoft/TypeScript/pull/21316#issuecomment-359574388\nexport function setDefaults<T extends AnyObject,U extends AnyObject>(obj: T, defaults: U) : Spread<T,U>;\nexport function setDefaults<T extends AnyObject,U extends AnyObject[]>(obj: T = Object.create(null), ...defaults: U) {\n    for(const def of defaults) {\n        for(const [k, v] of Object.entries(def)) {\n            if(obj[k] === undefined && v !== undefined) {\n                obj[k] = v;\n            }\n        }\n    }\n    return obj;\n}\n\nexport function isPlainObject(obj: any): obj is AnyObject  {\n    return isObject(obj) && (\n        obj.constructor === Object  // obj = {}\n        || obj.constructor === undefined // obj = Object.create(null)\n    );\n}\n\nexport function isObject(obj: any): obj is object {\n    return obj !== null && typeof obj === 'object';\n}\n\n\n// Remove types from T that are assignable to U\ntype Diff<T, U> = T extends U ? never : T;\n\n// Names of properties in T with types that include undefined\ntype OptionalPropertyNames<T> =\n    { [K in keyof T]: undefined extends T[K] ? K : never }[keyof T];\n\n// Common properties from L and R with undefined in R[K] replaced by type in L[K]\ntype SpreadProperties<L, R, K extends keyof L & keyof R> =\n    { [P in K]: L[P] | Diff<R[P], undefined> };\n\n// Type of { ...L, ...R }\ntype Spread<L, R> =\n    // Properties in L that don't exist in R\n    & Pick<L, Diff<keyof L, keyof R>>\n    // Properties in R with types that exclude undefined\n    & Pick<R, Diff<keyof R, OptionalPropertyNames<R>>>\n    // Properties in R, with types that include undefined, that don't exist in L\n    & Pick<R, Diff<OptionalPropertyNames<R>, keyof L>>\n    // Properties in R, with types that include undefined, that exist in L\n    & SpreadProperties<L, R, OptionalPropertyNames<R> & keyof L>;"]}