/// <reference types="node" />
import ResultWrapper from './ResultWrapper';
import { Dict, QueryParams, ResultPromise, ResultSetHeader } from './types';
import { GeometryType, PoolConfig } from 'mysql';
export declare function escapeIdString(id: string): string;
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
interface DatabaseOptions extends Omit<PoolConfig, 'typeCast'> {
    sqlMode?: string | string[];
    foreignKeyChecks?: boolean;
    safeUpdates?: boolean;
    typeCast?: (field: FieldType, next: NextFunc) => void;
    middleware?: Array<(sql: string, params: QueryParams | undefined, next: (sql: string, params?: QueryParams) => ResultPromise) => ResultPromise>;
}
export declare type FieldType = {
    type: 'DECIMAL' | 'TINY' | 'SHORT' | 'LONG' | 'FLOAT' | 'DOUBLE' | 'NULL' | 'TIMESTAMP' | 'LONGLONG' | 'INT24' | 'DATE' | 'TIME' | 'DATETIME' | 'YEAR' | 'NEWDATE' | 'VARCHAR' | 'BIT' | 'JSON' | 'NEWDECIMAL' | 'ENUM' | 'SET' | 'TINY_BLOB' | 'MEDIUM_BLOB' | 'LONG_BLOB' | 'BLOB' | 'VAR_STRING' | 'STRING' | 'GEOMETRY';
    length: number;
    db: string;
    table: string;
    name: string;
    string(): string;
    buffer(): Buffer;
    geometry(): GeometryType;
};
export declare type NextFunc = () => void;
export default class DatabaseWrapper {
    private readonly pool;
    private readonly pending;
    private readonly options;
    constructor(options: DatabaseOptions);
    query<TRecord extends object = Dict>(sql: string, params?: QueryParams): ResultWrapper<TRecord>;
    exec(sql: string, params?: QueryParams): Promise<ResultSetHeader>;
    escape(value: any): string;
    escapeId(id: any): string;
    stream<T extends object = Dict>(sql: string, params?: QueryParams): AsyncIterable<T>;
    waitForPending(): Promise<void>;
    close(): void;
}
export {};
