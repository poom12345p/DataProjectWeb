"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MySql = require("mysql2/promise");
const ResultWrapper_1 = require("./ResultWrapper");
const from_emitter_1 = require("@async-generators/from-emitter");
const formatSql_1 = require("./formatSql");
const util_1 = require("./util");
function escapeIdString(id) {
    return '`' + String(id).replace(/`/g, '``') + '`';
}
exports.escapeIdString = escapeIdString;
class DatabaseWrapper {
    constructor(options) {
        this.options = util_1.setDefaults(options, {
            timezone: 'Z',
            queryFormat: formatSql_1.default,
            charset: 'utf8mb4_unicode_520_ci',
            connectionLimit: 10,
            typeCast: (field, next) => {
                if (field.type === 'BIT' && field.length === 1) {
                    let buf = field.buffer();
                    return buf[0] === 1;
                }
                return next();
            },
            sqlMode: [
                'ONLY_FULL_GROUP_BY',
                'STRICT_TRANS_TABLES',
                'STRICT_ALL_TABLES',
                'NO_ZERO_IN_DATE',
                'NO_ZERO_DATE',
                'ERROR_FOR_DIVISION_BY_ZERO',
                'NO_ENGINE_SUBSTITUTION',
                'NO_UNSIGNED_SUBTRACTION',
                'PAD_CHAR_TO_FULL_LENGTH',
            ],
            middleware: [],
        });
        let { sqlMode, foreignKeyChecks, safeUpdates, middleware, ...poolOptions } = this.options;
        this.pool = MySql.createPool(poolOptions);
        this.pending = new Set;
        if (sqlMode != null || foreignKeyChecks != null) {
            if (Array.isArray(sqlMode)) {
                sqlMode = sqlMode.join(',');
            }
            this.pool.on('connection', (conn) => {
                if (sqlMode != null) {
                    conn.query(`SET sql_mode=?`, [sqlMode]);
                }
                if (foreignKeyChecks != null) {
                    conn.query(`SET foreign_key_checks=?`, [foreignKeyChecks ? 1 : 0]);
                }
                if (safeUpdates != null) {
                    conn.query(`SET sql_safe_updates=?`, [safeUpdates ? 1 : 0]);
                }
            });
        }
    }
    query(sql, params) {
        let mwIdx = 0;
        const pool = this.pool;
        const middlewareStack = this.options.middleware || [];
        function next(sql, params) {
            if (middlewareStack.length > mwIdx) {
                return middlewareStack[mwIdx++](sql, params, next);
            }
            return pool.query(sql, params);
        }
        const promise = next(sql, params);
        this.pending.add(promise);
        promise.finally(() => this.pending.delete(promise));
        return new ResultWrapper_1.default(promise);
    }
    async exec(sql, params) {
        const promise = this.pool.query(sql, params);
        this.pending.add(promise);
        try {
            return (await promise)[0];
        }
        finally {
            this.pending.delete(promise);
        }
    }
    escape(value) {
        return this.pool.escape(value);
    }
    escapeId(id) {
        if (Array.isArray(id)) {
            return id.map(escapeIdString).join('.');
        }
        return escapeIdString(id);
    }
    stream(sql, params) {
        return from_emitter_1.default(this.pool.pool.query(sql, params), {
            onNext: 'result',
            onError: 'error',
            onDone: 'end',
        });
    }
    async waitForPending() {
        await Promise.all(this.pending);
    }
    close() {
        return this.pool.end();
    }
}
exports.default = DatabaseWrapper;
//# sourceMappingURL=DatabaseWrapper.js.map